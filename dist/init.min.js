export function init(t,e,i){e.init=init;const n=t.content.cloneNode(!0);if(e.template=n,e.transform){const t=n.firstElementChild;null!==t&&(e.leaf=t,process(e,0,0))}return i.appendChild(e.template),e}function inheritTemplate(t,e){return t.inheritMatches?Object.assign(Object.assign({},t.transform),e):e}export function process(t,e,i){const n=t.leaf;if(void 0===n.matches)return;const o=t.transform;let s=null,l=!1,r=!1;t.inheritMatches=!1;for(const a in o)if(n.matches(a)){const c=(0,o[a])({target:n,ctx:t,idx:e,level:i});if(void 0!==c){if(void 0!==c.drill&&(s=null===s?c.drill:Object.assign(s,c.drill)),void 0!==c.matchFirstChild)switch(typeof c.matchFirstChild){case"boolean":"boolean"==typeof l&&c.matchFirstChild&&(l=!0);break;case"object":"object"==typeof l?Object.assign(l,c.matchFirstChild):l=c.matchFirstChild}if(void 0!==c.matchNextSib)switch(typeof c.matchNextSib){case"boolean":"boolean"==typeof r&&c.matchNextSib&&(r=!0);break;case"object":"object"==typeof r?Object.assign(r,c.matchNextSib):r=c.matchNextSib}}}if(r){let o=t.transform;"object"==typeof r&&(t.transform=inheritTemplate(t,r));const s=n.nextElementSibling;null!==s&&(t.leaf=s,process(t,e+1,i)),t.transform=o}if(l||null!==s){let e,o=t.transform;if(null!==s){const i=Object.keys(s);e=n.querySelector(i[0]),t.transform=inheritTemplate(t,s)}else e=n.firstElementChild,"object"==typeof l&&(t.transform=inheritTemplate(t,l));null!==e&&(t.leaf=e,process(t,0,i+1)),t.transform=o}}