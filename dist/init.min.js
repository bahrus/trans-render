export function init(e,t,n,s){const o="template"===e.localName?e.content.cloneNode(!0):e;if(t.template=o,t.Transform){const e=o.firstElementChild;null!==e&&(t.leaf=e,process(t,0,0,s))}let c="appendChild";if(s){s.prepend&&(c="prepend");const e=s.initializedCallback;void 0!==e&&e(t,n,s)}return n[c](t.template),t}function isTR(e){const t=Object.keys(e)[0];return-1==="SNTM".indexOf(t)}export function process(e,t,n,s){const o=e.leaf;if(void 0===o.matches)return;const c=e.Transform;let i={},r="",l=!0,a=!0,f=!1,m=[];for(const s in c)if(o.matches(s)){const p=c[s];switch(typeof p){case"object":r="*",Object.assign(i,p);break;case"function":const s=p({target:o,ctx:e,idx:t,level:n});if(void 0!==s)switch(typeof s){case"string":o.textContent=s;break;case"object":if(isTR(s)){const e=s;r="*",Object.assign(i,e)}else{const t=s;f=f||!!s.MergeTransforms,r=(l?"":",")+t.Select,l=!1;const n=t.Transform;void 0===n?Object.assign(i,e.Transform):Object.assign(i,n),t.SkipSibs&&(a=!1),!a&&s.NextMatch&&m.push(s.NextMatch)}}}}if(a){let c=e.Transform;const i=o.nextElementSibling;null!==i&&(e.leaf=i,process(e,t+1,n,s)),e.Transform=c}else if(m.length>0){const c=m.join(",");let i=o.nextElementSibling;for(;null!==i;){if(i.matches(c)){e.leaf=i,process(e,t+1,n,s);break}i=i.nextElementSibling}}if(r.length>0){let t=e.Transform;const c=o.querySelector(r);f&&Object.assign(i,e.Transform),null!==c&&(e.leaf=c,e.Transform=i,process(e,0,n+1,s),e.Transform=t)}}