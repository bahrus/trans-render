export function init(e,t,n,s){const o="template"===e.localName,i=o?e.content.cloneNode(!0):e;if(t.Transform){const e=i.firstElementChild;null!==e&&(t.leaf=e,process(t,0,0,s))}if(o){let e="appendChild";if(s){s.prepend&&(e="prepend");const o=s.initializedCallback;void 0!==o&&o(t,n,s)}n[e](i)}return t}export function process(e,t,n,s){const o=e.leaf;if(void 0===o.matches)return;const i=e.Transform;let l={},r="",c=!0,a=!0,f=!1,m=[];for(const s in i)if(o.matches(s)){let p=i[s];switch("function"==typeof p&&(p=p({target:o,ctx:e,idx:t,level:n})),typeof p){case"string":o.textContent=p;break;case"object":let s=!0;const i=Object.keys(p);if(i.length>0){const e=i[0][0];s=-1==="SNTM".indexOf(e)}if(s){const e=p;r="*",Object.assign(l,e)}else{const t=p;f=f||!!p.MergeTransforms,void 0!==t.Select&&(r=(c?"":",")+t.Select,c=!1);const n=t.Transform;void 0===n?Object.assign(l,e.Transform):Object.assign(l,n),t.SkipSibs&&(a=!1),!a&&p.NextMatch&&m.push(p.NextMatch)}}}if(a){let i=e.Transform;const l=o.nextElementSibling;if(null!==l&&(e.leaf=l,process(e,t+1,n,s)),e.Transform=i,m.length>0){const i=m.join(",");let l=o.nextElementSibling;for(;null!==l;){if(l.matches(i)){e.leaf=l,process(e,t+1,n,s);break}l=l.nextElementSibling}}}if(r.length>0){let t=e.Transform;const i=o.querySelector(r);f&&Object.assign(l,e.Transform),null!==i&&(e.leaf=i,e.Transform=l,process(e,0,n+1,s),e.Transform=t)}}