export function init(e,t,n,s){const o="template"===e.localName,c=o?e.content.cloneNode(!0):e;if(t.template=c,t.Transform){const e=c.firstElementChild;null!==e&&(t.leaf=e,process(t,0,0,s))}if(o){let e="appendChild";if(s){s.prepend&&(e="prepend");const o=s.initializedCallback;void 0!==o&&o(t,n,s)}n[e](t.template)}return t}export function process(e,t,n,s){const o=e.leaf;if(void 0===o.matches)return;const c=e.Transform;let i={},l="",r=!0,a=!0,f=!1,m=[];for(const s in c)if(o.matches(s)){const p=c[s];switch(typeof p){case"object":l="*",Object.assign(i,p);break;case"function":const s=p({target:o,ctx:e,idx:t,level:n});if(void 0!==s)switch(typeof s){case"string":o.textContent=s;break;case"object":let t=!0;const n=Object.keys(s);if(n.length>0){const e=n[0][0];t=-1==="SNTM".indexOf(e)}if(t){const e=s;l="*",Object.assign(i,e)}else{const t=s;f=f||!!s.MergeTransforms,void 0!==t.Select&&(l=(r?"":",")+t.Select,r=!1);const n=t.Transform;void 0===n?Object.assign(i,e.Transform):Object.assign(i,n),t.SkipSibs&&(a=!1),!a&&s.NextMatch&&m.push(s.NextMatch)}}}}if(a){let c=e.Transform;const i=o.nextElementSibling;if(null!==i&&(e.leaf=i,process(e,t+1,n,s)),e.Transform=c,m.length>0){const c=m.join(",");let i=o.nextElementSibling;for(;null!==i;){if(i.matches(c)){e.leaf=i,process(e,t+1,n,s);break}i=i.nextElementSibling}}}if(l.length>0){let t=e.Transform;const c=o.querySelector(l);f&&Object.assign(i,e.Transform),null!==c&&(e.leaf=c,e.Transform=i,process(e,0,n+1,s),e.Transform=t)}}