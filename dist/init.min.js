export function init(t,e,n){const s=t.content.cloneNode(!0);if(e.template=s,e.transform){const t=s.firstElementChild;null!==t&&(e.leaf=t,process(e,0,0))}return n.appendChild(e.template),e}function inheritTemplate(t,e,n){return n?Object.assign(Object.assign({},t.transform),e):e}export function process(t,e,n){const s=t.leaf;if(void 0===s.matches)return;const i=t.transform;let l=null,o=!1,r=!1,c=!1,a=[];for(const f in i)if(s.matches(f)){const m=(0,i[f])({target:s,ctx:t,idx:e,level:n});if(void 0!==m)switch(typeof m){case"string":s.textContent=m;break;case"object":if(c=c||!!m.inheritMatches,void 0!==m.select&&(l=null===l?m.select:Object.assign(l,m.select)),void 0!==m.matchFirstChild)switch(typeof m.matchFirstChild){case"boolean":"boolean"==typeof o&&m.matchFirstChild&&(o=!0);break;case"object":"object"==typeof o?Object.assign(o,m.matchFirstChild):o=m.matchFirstChild}m.matchNextSib&&(r=!0),!r&&m.nextMatch&&a.push(m.nextMatch)}}if(r){let i=t.transform;"object"==typeof r&&(t.transform=inheritTemplate(t,r,c));const l=s.nextElementSibling;null!==l&&(t.leaf=l,process(t,e+1,n)),t.transform=i}else if(a.length>0){const i=a.join(",");let l=s.nextElementSibling;for(;null!==l;){if(l.matches(i)){t.leaf=l,process(t,e+1,n);break}l=l.nextElementSibling}}if(o||null!==l){let e,i=t.transform;if(null!==l){const n=Object.keys(l);e=s.querySelector(n[0]),t.transform=inheritTemplate(t,l,c)}else e=s.firstElementChild,"object"==typeof o&&(t.transform=inheritTemplate(t,o,c));null!==e&&(t.leaf=e,process(t,0,n+1)),t.transform=i}}