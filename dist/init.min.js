export function init(e,t,n,s){const o="template"===e.localName?e.content.cloneNode(!0):e;if(t.template=o,t.Transform){const e=o.firstElementChild;null!==e&&(t.leaf=e,process(t,0,0,s))}return n[s&&s.prepend?"prepend":"appendChild"](t.template),t}function isTR(e){const t=Object.keys(e)[0];return-1==="SNTM".indexOf(t)}export function process(e,t,n,s){const o=e.leaf;if(void 0===o.matches)return;const c=e.Transform;let r={},i="",a=!0,l=!0,f=!1,m=[];for(const s in c)if(o.matches(s)){const p=c[s];switch(typeof p){case"object":i="*",Object.assign(r,p);break;case"function":const s=p({target:o,ctx:e,idx:t,level:n});if(void 0!==s)switch(typeof s){case"string":o.textContent=s;break;case"object":if(isTR(s)){const e=s;i="*",Object.assign(r,e)}else{const t=s;f=f||!!s.MergeTransforms,i=(a?"":",")+t.Select,a=!1;const n=t.Transform;void 0===n?Object.assign(r,e.Transform):Object.assign(r,n),t.SkipSibs&&(l=!1),!l&&s.NextMatch&&m.push(s.NextMatch)}}}}if(l){let c=e.Transform;const r=o.nextElementSibling;null!==r&&(e.leaf=r,process(e,t+1,n,s)),e.Transform=c}else if(m.length>0){const c=m.join(",");let r=o.nextElementSibling;for(;null!==r;){if(r.matches(c)){e.leaf=r,process(e,t+1,n,s);break}r=r.nextElementSibling}}if(i.length>0){let t=e.Transform;const c=o.querySelector(i);f&&Object.assign(r,e.Transform),null!==c&&(e.leaf=c,e.Transform=r,process(e,0,n+1,s),e.Transform=t)}}